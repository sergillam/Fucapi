#include <bits/stdc++.h>
using namespace std;

bool valida_insercao(int x , int y , int aux[][2] ,int tam);
bool simetrico (bool num[] , int tam,int V[][2]);
void ordena_matriz(int aux[][2], int tam );
void imprimi_matriz (int aux[][2], int tam);
void leitura_pares(int V[][2],int q ,int aux[][2],int *tam,int m , int n );
void verifica_pares(int V[][2],int q,bool num[]);


int main(){
	
	 int m , n; // Intervalo do conjunto;
	 int q ; //quantidade de elementos do conjunto;
		
	
	cout << "Informe o intervalo do conjunto: ";
	cin >> m >> n;//Leitura do intervalo do conjunto
	
	do {
	cout << "Informe a quantidade de pares que será lido: ";
	cin >> q;//Leitura da quantidade de pares que será lido 
	}while(q > pow (2, (n-m+1) )); // Verifica que a quantidade de numero que deseja ler é compativel com o tamanho maximo do conjunto.
	
	int V[q][2];// Vetor que armazenara os pares;
	int aux[q*2][2];// Vetor auxiliar que armazenara todas as possiveis combinações de pares;
	int tam=0; // Variavel que determinara o tamanho do vetor auxiliar
	bool num[q]; // Vetor que determina se o numero foi ou não utilizado;
	
	memset (num , false,q); // inicializa o vetor de booleano com falso;
	
	leitura_pares(V,q,aux,&tam,m,n);// Leitura do pares de numeros e armazena no vetor auxiliar todas as combinações póssiveis

	// Faz A verificação pra ver qual será a saída.
       if (simetrico(num,q,V)) {// Caso seja TRUE , todos os pares informados tem um par simetrico e faz a saida solicitadas
		  cout << "1" << endl;
	   }  
		else {// Caso seja FALSE , imprimi 0 e todos os pares de numeros e faz a saida solicitada	
			cout << "0" << endl;
			 imprimi_matriz(aux, tam) ;
		}
	return 0;	
}

void verifica_pares(int V[][2],int q,bool num[]){ // verifica se o par simetrico existe 
	int i,j;
	for (i = 0 ; i < q ; i++){ // verifica se o par ordenado tem seu par simetrico ( manipulando o vetor por dois indices o "i" e "j")
		for (j=0; j < q;j++){
			if (i == j && V[i][0] == V[i][1] && V[j][0] == V[j][1] && V[i][0] == V[j][0]  ) { // se "i " e "j" forem igual e os valores  manipulador também forem igualis, logo temos um par ordenado onde seu simetrico e ele mesmo;
			
				num[i] = true;	
			}
			else if (V[i][0] == V[j][1]  &&  V[i][1] == V[j][0]  && i!=j  )  {// verifica se  o par ordenado "i" tem seu simetrico quando "j" é manipulado
		
				num[i] = true;	
			}
		}	
	}
}

void leitura_pares(int V[][2],int q ,int aux[][2],int *tam,int m , int n ){ // faz a leitura dos pares numericos
	cout << "Os pares de numeros gerados automaticamente : " << endl;
	int i,Tam = *tam;
	srand((unsigned) time(NULL)); // trecho de código que gera numero aleatoriamente dentro do intervalo [m,n] solicitado pelo úsuario.
	for (i = 0 ; i < q ; i++){
		V[i][0] = m+(rand())%(m-n+1); // faz o sorteio dos numeros pegando apenas dentro desse intervalo [m,n] 
		V[i][1] = m+(rand())%(m-n+1);; // faz o sorteio dos numeros pegando apenas dentro desse intervalo [m,n] 
	
		if (valida_insercao (V[i][0],V[i][1],aux,Tam) ) { 
			cout <<  V[i][0] << "  " << V[i][1] << endl;
			if (V[i][0] == V[i][1] ){ // insere o par ordenado sem seu simetrico pois seu simetrico e ele mesmo (1,1 ou 2,2 por exemplo)
				aux [Tam][0] = V[i][0];
				aux [Tam][1] = V[i][1];
				Tam++;
			}
			else { // Insere o par ordenado digitado e o seu simetrico no vetor auxiliar
				aux [Tam][0] = V[i][0];
				aux [Tam][1] = V[i][1];
				Tam++;
				aux [Tam][0] = V[i][1];
				aux [Tam][1] = V[i][0];
				Tam++;	
			}
		}
		else { // Caso o  par de numero não seja inserido o "i " é decrementado para a interação ser desconsiderada ;
 			i--;
		}
	}
	*tam = Tam;
}


bool valida_insercao(int x , int y , int aux[][2] ,int tam){// Impede que no vetor auxiliar tenha elementos repetidos ( simula uma tabela hash)
	int i;
		for (i = 0 ; i < tam ; i++){
			if ( (aux[i][0] == x && aux[i][1] == y  ) || (aux[i][1] == x && aux[i][0] == y  ) ) {
					return false;// Caso o par ordenado passado , já exista no vetor
			}
		}
	return true; // Caso o par ordenado passado , ainda não existe no vetor
}

bool simetrico (bool num[] , int q,int V[][2]){ // Verifica se todos os pares tem simetria
	int i;
	verifica_pares(V,q,num); // verifica se o par ordenado tem seu par simetrico
	
		for (i = 0 ; i<q;i++){		
			if (!num[i]){
				return false; //  se algum elemento não tiver encontrado seu par simetrico;
			}
		}	
	return true;	// caso todos os elementos tenham encontrado seu par simetrico;
}

void ordena_matriz(int aux[][2], int tam ){ // Ordena a matriz de acordo com o solicitado no edital
	int i ,j;
	int troca;
	for (i=0 ; i < tam -1; i++){
		for (j=i;j<tam ; j++){	
			if ( aux[i][0] >=  aux [j][0] ){ // caso os numeros sejam igual ele modifica somente o segundo elemento
				if ( aux[i][0] ==  aux [j][0] && aux[i][1] >  aux [j][1] ){
					troca = aux[j][1];
					aux[j][1] = aux[i][1];
					aux[i][1] = troca;				
				}
				else if ( aux[i][0] > aux [j][0]  ){ // Caso o elemento manipulado por i [0] seja maior q o elemento manipulado em j [0] ele troca todo os pares ordenado
					troca = aux[j][0];
					aux[j][0] = aux[i][0];
					aux[i][0] = troca;

					troca = aux[j][1];
					aux[j][1] = aux[i][1];
					aux[i][1] = troca;
				}	
			}	
		}
	}		
}

void imprimi_matriz (int aux[][2], int tam){ // imprimi o vetor auxiliar com todas os pares que deveriam existir
	int i;
	ordena_matriz(aux,tam); // chama a função para ordenar o vetor
	
	for (i = 0 ; i < tam ;i++){
		cout << aux [i][0] << "  " << aux[i][1] << endl;
	}	
}
